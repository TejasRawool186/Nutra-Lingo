/**
 * Optimized Service Worker Configuration with Workbox
 * 
 * Caching Strategies:
 * - Cache First: Static assets (JS, CSS, fonts) - rarely change
 * - Stale While Revalidate: API responses - use old while fetching new
 * - Network First: HTML pages - always try fresh
 * - Network Only: Authenticated endpoints - no caching
 */

import { precacheAndRoute } from 'workbox-precaching';
import { registerRoute, NavigationRoute } from 'workbox-routing';
import {
  CacheFirst,
  StaleWhileRevalidate,
  NetworkFirst,
} from 'workbox-strategies';
import { CacheExpiration } from 'workbox-expiration';
import { BackgroundSyncPlugin } from 'workbox-background-sync';
import { ExpirationPlugin } from 'workbox-expiration';

// Enable self-updating of service worker
self.skipWaiting();

// Precache manifest (generated by Workbox)
precacheAndRoute(self.__WB_MANIFEST);

// Client claiming for immediate activation
self.clientsClaim();

// ─────────────────────────────────────────────────────────────
// 1. Cache-First: Static Assets (Long Expiration)
// ─────────────────────────────────────────────────────────────

registerRoute(
  ({ request }) =>
    request.destination === 'style' ||
    request.destination === 'script' ||
    request.destination === 'worker',
  new CacheFirst({
    cacheName: 'static-resources',
    plugins: [
      new ExpirationPlugin({
        maxEntries: 100,
        maxAgeSeconds: 60 * 60 * 24 * 30, // 30 days
      }),
    ],
  })
);

// ─────────────────────────────────────────────────────────────
// 2. Cache-First: Images (with long expiration)
// ─────────────────────────────────────────────────────────────

registerRoute(
  ({ request }) => request.destination === 'image',
  new CacheFirst({
    cacheName: 'image-cache',
    plugins: [
      new ExpirationPlugin({
        maxEntries: 200,
        maxAgeSeconds: 60 * 60 * 24 * 60, // 60 days
      }),
    ],
  })
);

// ─────────────────────────────────────────────────────────────
// 3. Cache-First: Fonts (very long expiration)
// ─────────────────────────────────────────────────────────────

registerRoute(
  ({ url }) =>
    url.origin === 'https://fonts.googleapis.com' ||
    url.origin === 'https://fonts.gstatic.com',
  new CacheFirst({
    cacheName: 'google-fonts-cache',
    plugins: [
      new ExpirationPlugin({
        maxEntries: 30,
        maxAgeSeconds: 60 * 60 * 24 * 365, // 1 year
      }),
    ],
  })
);

// ─────────────────────────────────────────────────────────────
// 4. Stale While Revalidate: API Responses (30 min cache)
// ─────────────────────────────────────────────────────────────

registerRoute(
  ({ url }) =>
    url.pathname.startsWith('/api/analyze') ||
    url.pathname.startsWith('/api/meal') ||
    url.pathname.startsWith('/api/alternatives'),
  new StaleWhileRevalidate({
    cacheName: 'api-cache-swr',
    plugins: [
      new ExpirationPlugin({
        maxEntries: 50,
        maxAgeSeconds: 60 * 30, // 30 minutes
      }),
      // Use background sync to retry failed requests
      new BackgroundSyncPlugin('api-backlog', {
        maxRetentionTime: 24 * 60, // 24 hours
      }),
    ],
  })
);

// ─────────────────────────────────────────────────────────────
// 5. Network First: Health Check & Metrics (never cache)
// ─────────────────────────────────────────────────────────────

registerRoute(
  ({ url }) =>
    url.pathname === '/api/health' ||
    url.pathname === '/api/metrics',
  new NetworkFirst({
    cacheName: 'api-network-only',
    networkTimeoutSeconds: 5,
    plugins: [
      new ExpirationPlugin({
        maxEntries: 5,
        maxAgeSeconds: 60 * 5, // 5 minutes fallback
      }),
    ],
  })
);

// ─────────────────────────────────────────────────────────────
// 6. Network First: HTML Pages (fetch fresh, fallback to cache)
// ─────────────────────────────────────────────────────────────

registerRoute(
  ({ request }) => request.mode === 'navigate',
  new NetworkFirst({
    cacheName: 'pages',
    networkTimeoutSeconds: 10,
    plugins: [
      new ExpirationPlugin({
        maxEntries: 20,
        maxAgeSeconds: 60 * 60 * 24 * 7, // 7 days
      }),
    ],
  })
);

// ─────────────────────────────────────────────────────────────
// 7. Cache Navigation Route (for SPA)
// ─────────────────────────────────────────────────────────────

const navigationRoute = new NavigationRoute(
  new NetworkFirst({
    cacheName: 'navigations',
    networkTimeoutSeconds: 10,
  }),
  {
    // Whitelist routes
    allowlist: [/^(?!\/_next\/|\/api\/).*/],
    // Blacklist auth & API routes
    denylist: [/^\/api\//, /^\/_next\//],
  }
);

registerRoute(navigationRoute);

// ─────────────────────────────────────────────────────────────
// 8. Message Handler (for cache management from client)
// ─────────────────────────────────────────────────────────────

self.addEventListener('message', (event) => {
  if (event.data && event.data.type === 'SKIP_WAITING') {
    self.skipWaiting();
  }

  if (event.data && event.data.type === 'CLEAR_CACHE') {
    const cacheName = event.data.cacheName;
    caches.delete(cacheName).then(() => {
      console.log(`Cache cleared: ${cacheName}`);
    });
  }

  if (event.data && event.data.type === 'GET_CACHE_SIZE') {
    caches.keys().then((cacheNames) => {
      let totalSize = 0;
      Promise.all(
        cacheNames.map((name) =>
          caches.open(name).then((cache) =>
            cache.keys().then((keys) => {
              totalSize += keys.length;
            })
          )
        )
      ).then(() => {
        event.ports[0].postMessage({ type: 'CACHE_SIZE', size: totalSize });
      });
    });
  }
});

// ─────────────────────────────────────────────────────────────
// 9. Background Sync for Failed Requests
// ─────────────────────────────────────────────────────────────

self.addEventListener('sync', (event) => {
  if (event.tag === 'api-backlog') {
    event.waitUntil(
      caches
        .open('api-backlog')
        .then((cache) => cache.keys())
        .then((requests) => {
          return Promise.all(
            requests.map((request) => {
              return fetch(request.clone()).then((response) => {
                if (response.ok) {
                  return cache.delete(request);
                }
              });
            })
          );
        })
        .catch((error) => {
          console.error('Background sync failed:', error);
        })
    );
  }
});

// ─────────────────────────────────────────────────────────────
// 10. Push Notification Handler (for future features)
// ─────────────────────────────────────────────────────────────

self.addEventListener('push', (event) => {
  if (event.data) {
    const data = event.data.json();
    const options = {
      body: data.body || 'New notification',
      icon: '/icons/icon-192.png',
      badge: '/icons/icon-192.png',
      tag: 'notification',
      requireInteraction: false,
    };

    event.waitUntil(
      self.registration.showNotification(data.title || 'NutraLingo', options)
    );
  }
});

// ─────────────────────────────────────────────────────────────
// 11. Cache Size Monitoring
// ─────────────────────────────────────────────────────────────

const monitorCacheSize = async () => {
  if ('storage' in navigator && 'estimate' in navigator.storage) {
    const { usage, quota } = await navigator.storage.estimate();
    const percentUsed = (usage / quota) * 100;

    if (percentUsed > 90) {
      // Clear old caches if storage is > 90% full
      const cacheNames = await caches.keys();
      for (const name of cacheNames) {
        if (name.includes('api') || name.includes('image')) {
          caches.delete(name);
        }
      }
    }
  }
};

// Run cache size check periodically
setInterval(monitorCacheSize, 60000); // Every minute
